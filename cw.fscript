" vi: noet
"

"Tool to use to generate CW. Must accept input on stdin.
 Path must be absolute."
CW_TOOL_PATH := '/usr/local/bin/ebook2cw'.

"File generated by CW_TOOL. Must be playable by afplay."
CW_FILE := 'Chapter0000.mp3'.

"Absolute path to afplay.
"Used to play mp3 output of CW_TOOL."
AFPLAY_PATH := '/usr/bin/afplay'.

"The currently running generation task."
CURRENT_TASK := nil.

TERMINATE_MAP := nil.
on_termination := [ :task :block |
	"TODO: Subscribe to NSTaskDidTerminateNotification.
	"On successful completion, call block."
].

task_did_terminate := [ :note |
	|task|
	task := note object.
	"TODO: Look up block in TERMINATE_MAP and call it."
].

play_audio := [ :path |
	|task|
	task := NSTask alloc init.
	task setLaunchPath:AFPLAY_PATH.
	task setArguments:{AFPLAY_PATH, CW_FILE}.
	on_termination task [ task release. ].
	task launch.
].

to_audio := [ text |
	|task path pipe utf8 infile blackhole|
	task := NSTask alloc init.
	task setLaunchPath:CW_TOOL_PATH.
	task setArguments:{CW_TOOL_PATH}.

	pipe := NSPipe alloc init.
	utf8 := text dataUsingEncoding:NSUTF8StringEncoding.
	infile := pipe fileHandleForWriting.
	infile writeData:utf8.
	infile closeFile.
	task setStandardInput:pipe.
	pipe release.

	"ebook2cw writes a bunch of stats to stdout"
	blackhole := NSFileHandle fileHandleWithNullDevice.
	task setStandardOutput:blackhole.

	on_termination task [ play_audio CW_FILE. ].
	task launch.
].

"called on load and reload"
load := [ :scriptFilePath |
	sys log:'Colloquy cw plugin loaded'
].

"called on unload and reload"
unload := [
	sys log:'Colloquy cw plugin unloaded'
].

"return an array of NSMenuItems that should be dispalyed for 'object' associated with 'view'"
contextualMenuItems := [ :object :view |
	{}.
].

"process the command and return true if you handle it or false to pass on to another plugin"
processUserCommand := [ :command :arguments :connection :view |
	false.
].

"handle a ctcp request and return true if you handle it or false to pass on to another plugin"
processSubcodeRequest := [ :command :arguments :user |
	false.
].

"handle a ctcp reply and return true if you handle it or false to pass on to another plugin"
processSubcodeReply := [ :command :arguments :user |
	false.
].

"called when 'connection' connects"
connected := [ :connection |
	nil.
].

"called when 'connection' is disconnecting"
disconnecting := [ :connection |
	nil.
].

"perform a notification"
performNotification := [ :identifier :context :preferences |
	nil.
].

"called when an unhandled URL scheme is clicked in 'view'"
handleClickedLink := [ :url :view |
	false.
].

"called for each incoming message, the message is mutable"
processIncomingMessage := [ :message :view |
	nil.
].

"called for each outgoing message, the message is mutable"
processOutgoingMessage := [ :message :view |
	nil.
].

"called when a member joins 'room'"
memberJoined := [ :member :room |
	nil.
].

"called when a member parts 'room'"
memberParted := [ :member :room |
	nil.
].

"called when a member is kicked from 'room' for 'reason'"
memberKicked := [ :member :room :by :reason |
	nil.
].

"called when the local user joins 'room'"
joinedRoom := [ :room |
	nil.
].

"called when the local user is parting 'room'"
partingFromRoom := [ :room |
	nil.
].

"called when the local user is kicked from 'room' for 'reason'"
kickedFromRoom := [ :room :by :reason |
	nil.
].

"called when the topic changes in 'room'"
topicChanged := [ :topic :room :author |
	nil.
].
